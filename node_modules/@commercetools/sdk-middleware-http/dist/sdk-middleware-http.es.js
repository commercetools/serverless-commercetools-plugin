function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function defineError(statusCode, message) {
  var meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // eslint-disable-next-line no-multi-assign
  this.status = this.statusCode = this.code = statusCode;
  this.message = message;
  Object.assign(this, meta);
  this.name = this.constructor.name; // eslint-disable-next-line no-proto

  this.constructor.prototype.__proto__ = Error.prototype;
  if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
}
/* eslint-disable max-len, flowtype/require-parameter-type */


function NetworkError() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  defineError.call.apply(defineError, [this, 0
  /* special code to indicate network errors */
  ].concat(args));
}
function HttpError() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  defineError.call.apply(defineError, [this].concat(args));
}
function BadRequest() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  defineError.call.apply(defineError, [this, 400].concat(args));
}
function Unauthorized() {
  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  defineError.call.apply(defineError, [this, 401].concat(args));
}
function Forbidden() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  defineError.call.apply(defineError, [this, 403].concat(args));
}
function NotFound() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  defineError.call.apply(defineError, [this, 404].concat(args));
}
function ConcurrentModification() {
  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    args[_key7] = arguments[_key7];
  }

  defineError.call.apply(defineError, [this, 409].concat(args));
}
function InternalServerError() {
  for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
    args[_key8] = arguments[_key8];
  }

  defineError.call.apply(defineError, [this, 500].concat(args));
}
function ServiceUnavailable() {
  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    args[_key9] = arguments[_key9];
  }

  defineError.call.apply(defineError, [this, 503].concat(args));
}
/* eslint-enable max-len */

function getErrorByCode(code) {
  switch (code) {
    case 0:
      return NetworkError;

    case 400:
      return BadRequest;

    case 401:
      return Unauthorized;

    case 403:
      return Forbidden;

    case 404:
      return NotFound;

    case 409:
      return ConcurrentModification;

    case 500:
      return InternalServerError;

    case 503:
      return ServiceUnavailable;

    default:
      return undefined;
  }
}

var errors = /*#__PURE__*/Object.freeze({
  __proto__: null,
  NetworkError: NetworkError,
  HttpError: HttpError,
  BadRequest: BadRequest,
  Unauthorized: Unauthorized,
  Forbidden: Forbidden,
  NotFound: NotFound,
  ConcurrentModification: ConcurrentModification,
  InternalServerError: InternalServerError,
  ServiceUnavailable: ServiceUnavailable,
  'default': getErrorByCode
});

function parseHeaders(headers) {
  if (headers.raw) // node-fetch
    return headers.raw(); // Tmp fix for Firefox until it supports iterables

  if (!headers.forEach) return {}; // whatwg-fetch

  var map = {};
  headers.forEach(function (value, name) {
    map[name] = value;
  });
  return map;
}

function createError(_ref) {
  var statusCode = _ref.statusCode,
      message = _ref.message,
      rest = _objectWithoutProperties(_ref, ["statusCode", "message"]);

  var errorMessage = message || 'Unexpected non-JSON error response';
  if (statusCode === 404) errorMessage = "URI not found: ".concat(rest.originalRequest.uri);
  var ResponseError = getErrorByCode(statusCode);
  if (ResponseError) return new ResponseError(errorMessage, rest);
  return new HttpError(statusCode, errorMessage, rest);
} // calculates the delay duration exponentially
// More info about the algorithm use here https://goo.gl/Xk8h5f


function calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay) {
  if (backoff) return retryCount !== 0 // do not increase if it's the first retry
  ? Math.min(Math.round((Math.random() + 1) * retryDelay * Math.pow(2, retryCount)), maxDelay) : retryDelay;
  return retryDelay;
}

function maskAuthData(request, maskSensitiveHeaderData) {
  if (maskSensitiveHeaderData) {
    if (request.headers.authorization) request.headers.authorization = ['Bearer ********'];
    if (request.headers.Authorization) request.headers.Authorization = ['Bearer ********'];
  }
}

function createHttpMiddleware(_ref2) {
  var host = _ref2.host,
      credentialsMode = _ref2.credentialsMode,
      includeResponseHeaders = _ref2.includeResponseHeaders,
      includeOriginalRequest = _ref2.includeOriginalRequest,
      _ref2$maskSensitiveHe = _ref2.maskSensitiveHeaderData,
      maskSensitiveHeaderData = _ref2$maskSensitiveHe === void 0 ? true : _ref2$maskSensitiveHe,
      enableRetry = _ref2.enableRetry,
      timeout = _ref2.timeout,
      _ref2$retryConfig = _ref2.retryConfig;
  _ref2$retryConfig = _ref2$retryConfig === void 0 ? {} : _ref2$retryConfig;
  var _ref2$retryConfig$max = _ref2$retryConfig.maxRetries,
      maxRetries = _ref2$retryConfig$max === void 0 ? 10 : _ref2$retryConfig$max,
      _ref2$retryConfig$bac = _ref2$retryConfig.backoff,
      backoff = _ref2$retryConfig$bac === void 0 ? true : _ref2$retryConfig$bac,
      _ref2$retryConfig$ret = _ref2$retryConfig.retryDelay,
      retryDelay = _ref2$retryConfig$ret === void 0 ? 200 : _ref2$retryConfig$ret,
      _ref2$retryConfig$max2 = _ref2$retryConfig.maxDelay,
      maxDelay = _ref2$retryConfig$max2 === void 0 ? Infinity : _ref2$retryConfig$max2,
      fetcher = _ref2.fetch,
      _abortController = _ref2.abortController;
  if (!fetcher && typeof fetch === 'undefined') throw new Error('`fetch` is not available. Please pass in `fetch` as an option or have it globally available.');
  if (timeout && !_abortController && typeof AbortController === 'undefined') throw new Error('`AbortController` is not available. Please pass in `AbortController` as an option or have it globally available when using timeout.');
  if (!fetcher) // `fetcher` is set here rather than the destructuring to ensure fetch is
    // declared before referencing it otherwise it would cause a `ReferenceError`.
    // For reference of this pattern: https://github.com/apollographql/apollo-link/blob/498b413a5b5199b0758ce898b3bb55451f57a2fa/packages/apollo-link-http/src/httpLink.ts#L49
    // eslint-disable-next-line
    fetcher = fetch;
  var abortController;
  if (timeout || _abortController) // eslint-disable-next-line
    abortController = _abortController || new AbortController();
  return function (next) {
    return function (request, response) {
      var url = host.replace(/\/$/, '') + request.uri;
      var body = typeof request.body === 'string' || Buffer.isBuffer(request.body) ? request.body : // NOTE: `stringify` of `null` gives the String('null')
      JSON.stringify(request.body || undefined); // $FlowFixMe

      var requestHeader = _objectSpread2(_objectSpread2({
        'Content-Type': ['application/json']
      }, request.headers), body ? {
        'Content-Length': Buffer.byteLength(body).toString()
      } : null); // $FlowFixMe


      var fetchOptions = _objectSpread2(_objectSpread2(_objectSpread2({
        method: request.method,
        headers: requestHeader
      }, credentialsMode ? {
        credentials: credentialsMode
      } : {}), timeout || abortController ? {
        signal: abortController.signal
      } : {}), body ? {
        body: body
      } : null);

      var retryCount = 0; // wrap in a fn so we can retry if error occur

      function executeFetch() {
        // Kick off timer for abortController directly before fetch.
        var timer;
        if (timeout) timer = setTimeout(function () {
          abortController.abort();
        }, timeout); // $FlowFixMe

        fetcher(url, fetchOptions).then(function (res) {
          if (res.ok) {
            if (fetchOptions.method === 'HEAD') {
              next(request, _objectSpread2(_objectSpread2({}, response), {}, {
                statusCode: res.status
              }));
              return;
            }

            res.json().then(function (result) {
              var parsedResponse = _objectSpread2(_objectSpread2({}, response), {}, {
                body: result,
                statusCode: res.status
              });

              if (includeResponseHeaders) parsedResponse.headers = parseHeaders(res.headers);

              if (includeOriginalRequest) {
                parsedResponse.request = _objectSpread2({}, fetchOptions);
                maskAuthData(parsedResponse.request, maskSensitiveHeaderData);
              }

              next(request, parsedResponse);
            });
            return;
          }

          if (res.status === 503 && enableRetry) if (retryCount < maxRetries) {
            setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
            retryCount += 1;
            return;
          } // Server responded with an error. Try to parse it as JSON, then
          // return a proper error type with all necessary meta information.

          res.text().then(function (text) {
            // Try to parse the error response as JSON
            var parsed;

            try {
              parsed = JSON.parse(text);
            } catch (error) {
              parsed = text;
            }

            var error = createError(_objectSpread2({
              statusCode: res.status,
              originalRequest: request,
              retryCount: retryCount,
              headers: parseHeaders(res.headers)
            }, _typeof(parsed) === 'object' ? {
              message: parsed.message,
              body: parsed
            } : {
              message: parsed,
              body: parsed
            }));
            maskAuthData(error.originalRequest, maskSensitiveHeaderData); // Let the final resolver to reject the promise

            var parsedResponse = _objectSpread2(_objectSpread2({}, response), {}, {
              error: error,
              statusCode: res.status
            });

            next(request, parsedResponse);
          });
        }, // We know that this is a "network" error thrown by the `fetch` library
        function (e) {
          if (enableRetry) if (retryCount < maxRetries) {
            setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
            retryCount += 1;
            return;
          }
          var error = new NetworkError(e.message, {
            originalRequest: request,
            retryCount: retryCount
          });
          maskAuthData(error.originalRequest, maskSensitiveHeaderData);
          next(request, _objectSpread2(_objectSpread2({}, response), {}, {
            error: error,
            statusCode: 0
          }));
        }).finally(function () {
          clearTimeout(timer);
        });
      }

      executeFetch();
    };
  };
}

export { createHttpMiddleware, errors, getErrorByCode };
